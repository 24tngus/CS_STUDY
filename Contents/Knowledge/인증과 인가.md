## **1\. 인증(**Authentication**)과 인가(****Authorization)**

###  **1) 인증**

![image](https://github.com/24tngus/CS_STUDY/assets/122462263/55347265-156f-4096-bcc1-1ca581326310)

-   **인증요소를 통해 해당 리소스에 자신을 알려주는 것**
-   사용자의 신원을 확인하는 과정

###  **2) 인가( =권한부여 )**

![image](https://github.com/24tngus/CS_STUDY/assets/122462263/c5de1b78-275f-49c8-946e-1e2967561a90)

-    **사용자가 자원에 접근 권한을 얻는 것**
-   **사용자가 인증을 마치고 원하는 자원에 대한 권한을 얻는 과정**

ex) 내가 쓴 게시글들은 내가 보고 수정하고 삭제할 수 있지만 내가 쓰지 않은 게시물들은 권한이 없기 때문에 수정, 삭제를 할 수 없다.

## **2\. HTTP통신의** **특징**

#### **1) 무상태 프로토콜 , stateless**

![image](https://github.com/24tngus/CS_STUDY/assets/122462263/d3d36b03-a4b8-4c4f-a5b7-3f9f61a0fb19)

 클라이언트가 서버에 나는 누구누구야!라고 **알려주면(request)** 서버는 그거에 **응답(response)**해준다. 하지만 한번의 통신이 끝나면 서버는 클라이언트의 상태를 저장하지 않아 다음 통신때는 어떤 통신을 했는지 서버는 알지 못한다. 이러한 특징을  **무상태(stateless)**라고 한다. 

#### **2) 비 연결성, Connectionless**

![image](https://github.com/24tngus/CS_STUDY/assets/122462263/5b2f95d0-2cc9-43f3-b211-4c983cd50cf9)

 클라이언트가 서버에 특정 url요청을 보내면 서버는 해당 url로 클라이언트가 접속 할 수 있게 해준다. 그러고 **서버는 해당 연결을 바로 끊어버린다.** 이걸 **비연결성(connectionless)**라고 말한다. 

## **3\. 인증 인가 방식**

#### **1) Cookie**

-   사용자가 웹사이트를 접속했을 때 서버에서 사용자의 브라우저로 전송하는 작은 데이터
-   브라우저는 서버에서 받은 쿠키를 저장해 놨다가 동일한 서버로 요청을 다시 받았을 때 저장된 쿠키를 함께 전송한다.
-   사용자의 pc에 저장되어 사용된다.
-   ex) 아이디저장, 팝업창에  '오늘은 더이상 보지 않기' 

**● 장점** 

-   속도가 빨라서 서버의 자원낭비가 줄어든다. -> 효율적이다.
-   브라우저가 종료되도 자동삭제가 안된다.

**● 단점**

-   pc에 저장되기 때문에 해킹의 위험성이 있다.

**\-> 민감한 정보를 저장하지 않는다.**

#### **2) Session**

-   일정시간 사용자의 상태를 일정하게 유지시기는 기술
-   서버에 저장된다 -> 일정 시간 사용자의 상태를 저장할 수 있다.
-   브라우저를 종료하게 되면 세션이 끊긴다.
-   ex) 새로고침해도 로그인상태 유지

**● 장점** 

-   서버에서 관리되기 때문에 쿠키보다는 안전한 상태로 유지
-   브라우저가 종료되면 자동삭제가 되기 때문에 보안성이 높다.

**● 단점**

-   서버에서 관리하기 때문에 많은 사람이 사용하게되면 서버에 과부하가 된다.

> ****쿠키 + 세션 프로세스   
> ● 보통 쿠키 + 세션을 같이 사용한다.  
> ****![image](https://github.com/24tngus/CS_STUDY/assets/122462263/c10557e7-1dea-4a75-bd59-1f6f091d65e6)
> 
>   
> **● 세션은 고객의 식별값을 생성하고 해당 정보를 쿠키에 담겨 서버로 보내진다.  
> **  
> 1\. 사용자가 브라우저에 정보를 입력하면 정보가 쿠키에 저장되어 서버로 보내진다.  
> 2\. 서버는 쿠키에 저장된 세션ID를 확인하고 없을 경우 세션ID를 생성 후 DB에 저장한다.  
> 3\. 쿠키에 세션ID값을 저장해 사용자에게 응답을 주고 사용자PC에 쿠키가 저장된다.  
> 4\. 후에 사용자가 요청을 보내면 세션ID가 포함된 쿠키를 서버로 보낸다.  
> 5\. 세션저장소에서 쿠키에 저장된 세션ID를 통해 사용자를 식별한다.  
> 6\. 사용자에게 응답을 보내준다.  
>   
> **● 단점  
> \- 사용자 PC에 쿠키가 저장되기 때문에 보안이 떨어진다.  
> \- 서버에 저장된 세션값이 많아지면 서버가 느려진다.**

#### **3) Token**

-   **사용자의 인증정보를 암호화한 것**
-   일종의 출입증 역할
-   토큰 유효기간동안 웹페이지를 접속할 때마다 인증을 새로 할 필요 없이 발급된 토큰을 이용해서 접속이 가능하다. ex) 사용자가 최초 로그인을 할 때 토큰이 발급되고 발급된 토큰이 다른 페이지도 접속할 수 있도록 권한을 줄 수 있다.

#### **① 특징**

-   **확장성이 좋다 : stateless한 구조**
-   **보안성이 높다** : 쿠키를 사용하지 않아 쿠키의 취약점 해결
-   **토큰은 선택적으로 권한을 발급** -> 소셜로그인을 통한 선택적 권한 발급

> ****토큰 프로세스  
> ****
![image](https://github.com/24tngus/CS_STUDY/assets/122462263/abe9b653-24ec-4430-934d-02c3eeb914a7)
1. 사용자가 브라우저에서 로그인 시도를 한다.  
> 2\. 사용자가 입력한 정보를 DB에서 조회해 사용자 정보를 확인하고 access 토큰을 발급해준다.  
> 3\. 발급된 토큰과 함께 사용자에게 응답을 해준다  
> 4\. 사용자는 저장된 토큰을 통해 서버에 데이터를 요청한다.  
> 5\. 서버에서 access 토큰을 검증하고 인가처리를 해준다.  
>   
> **● Refresh 토큰을 발급하는 이유**  
>  access 토큰의 유효기간이 짧기 떄문에 로그인을 자주 하게 된다. 그래서 access 토큰의 유효기간을 길게하게되면  보안문제가 생긴다.  토큰은 statelsess한 특징을 갖기 때문에 **서버에서 토큰에 대해 제어권을 갖고있지 않는다.** 그래서 토큰이 탈취를 당하면 후속조치가 불가능하다는 문제가 생긴다.  
>   
>  그래서 **access토큰을 발급하는 동시에 refresh 토큰도 발급**해준다. access토큰이 만료되었을 때,  refresh토큰을 통해 access토큰을 자주 재발급받게 하면서 보안성을 높여준다.  
> **_\*Refresh 토큰 : Access Token이 만료되었을 때 Access Token을 새로 발급받기 위해 사용되는 토큰_**

#### **② 토큰  인증 방식**

#### **● JWT**

-   유저 정보를 담은 JSON 데이터를 암호화 해서 서버와 클라이언트 사이에서 주고받는 것
-   JSON 데이터를 **Base64 URL-safe Encode** 를 통해 인코딩하여 직렬화했다. 

#### ****●** JWT 구조**

![image](https://github.com/24tngus/CS_STUDY/assets/122462263/39f1c15e-7374-499d-9993-361b610406f5)

-   **헤더**
    -   typ : 토큰의 타입  
    -   alg : 해시 알고리즘

```
{"typ":"JWT","alg":"HS256"}
```

-   **페이로드**
    -   클라이언트와 서버가 주고받는 데이터
    -   토큰에서 사용할 정보의 조각들인 claim 이 담겨있다. 
    -   유저 정보가 유출되면 안된다.

**_\* claim : key-value 형식으로 이루어진 한 쌍의 정보_**

```
{"id" : a , "pw" : 1234}
```

-   **서명**
    -   JWT가 원본 그대로라는 것을 확인해준다
    -   인코딩한 헤더와 페이로드의 정보를 알고리즘으로 암호화한다.
    -   누구나 계약서를 볼 수 있기때문에 개인정보를 담으면 안됨

#### ****●**  JWT  장점 & 단점**

**▽ 장점**

-   헤더와 페이로드를 가지고 서명을 생성하기 떄문에 **위변조를 막을 수 있다.**
-   인증정보에 대한 **별도의 저장소가 필요없다.**
-    토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명 등 필**요한 모든 정보를 자체적으로 지니고 있다.**
-   **서버는 무상태(StateLess)**가 되어 서버 확장성이 우수해질 수 있다.
-   **다른 로그인 시스템에 접근 및 권한 공유가 가능하다**
-   모바일 어플리케이션 환경에서도 잘 동작한다.

**▽ 단점**

-   토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.
-   정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.
-    페이로드는 BASE64로 인코딩 된 것이기 때문에, 중간에 탈취해서 디코딩하면 데이터를 볼 수 있다 -> 중요한 정보는 넣으면 안된다.
-   stateless 특징때문에 클라이언트에서 관리하는데  탈취당하면 후속조치 불가