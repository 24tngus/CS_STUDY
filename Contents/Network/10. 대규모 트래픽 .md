### 📕 대규모 트래픽으로 인한 서버 과부하 해결방법

#### 1. 서버 과부하

- 1) 개념
  - 서버가 리소스를 소진하여 들어오는 요청을 처리하지 못함
  - 🗒️ 예시 : 서버는 사용자의 웹요청을 처리하지 못해 응답없음이 뜸
  ![](https://velog.velcdn.com/images/24tngus/post/4c589e73-2159-4742-bc00-c2b002e80611/image.png)
  
- 2) 해결 방법
  - 모니터링을 통한 자원 할당
  - 로드밸런서
  - 블랙스완 프로토콜
  - 서킷 브레이커
  - 컨텐츠 관리

#### 2. 모니터링을 통한 자원 할당

- 1) 원인
  - 자원(CPU, 메모리, 대역폭 등)의 한계점 도달
  - 보통 서버의 CPU 사용량이 80~90%에 도달하거나 메모리가 부족해 계속 스와핑하면 과부하
  
- 2) 모니터링 
  - 서버 과부화로 인한 서버 중지 대처
    - 어떤 페이지에 어떤 트래픽이 얼마나 발생했는지 확인
    - 어떤 네트워크에서 병목현상이 일어났는지 확인
  - 모니터링을 하면 페이지 활용도 높은지/낮은지 파악하여 서비스 개선에 도움
  - 해결하기 위한 문제점 파악
  - [cloudflare](https://www.cloudflarestatus.com/)는 모니터링 결과와 함께 서비스 중단 여부를 사용자에게 알림

- 3) **AWS 오토스케일링**
  - 서비스 이용불가능 상태 발생 이전 cloud watch가 계속 모니터링하여 서버 대수 늘려주는 방법
  - 애플리케이션을 자동으로 모니터링하고 자원의 용량을 자동으로 조정함
  
- 4) **[netdata](https://github.com/netdata/netdata)**를 이용한 모니터링
  - AWS 대체하는 무료 모니터링 서비스 
  - 지속적인 모니터링, 자원할당 해결
  - slack과 연동하여 설정한 임계치를 기반으로 알림서비스 구축 가능
  
#### 3. 로드밸런서

- 1) 개념
  - 서버 앞단에서 로드밸런스 통해 트래픽 분산
  - 한 서버에 장애가 발생하면 트래픽을 다른 기능 서버로 리다이렉션하여 시스템 중단 방지
  ![](https://velog.velcdn.com/images/24tngus/post/e22fca9b-97b2-41c0-b1ba-516529477007/image.png)

  
#### 4. 블랙스완 프로토콜

- 1) 블랙스완 개념
  - 예측할 수 없는 사고가 일어난 것
  - 사후에는 이 사고의 원인 분석할 수 있지만, 사전에는 사고를 예측할 수 없음
  
- 2) 블랙스완 발생시 운영 수칙
  - 영향을 받은 시스템과 각 시스템의 상대적 **위험 수준을 확인**
    - 체계적으로 데이터 수집
    - 원인에 대한 가설을 수립한 후 테스팅
  - 잠재적으로 영향을 받을 수 있는 **내부의 모든 팀에 연락**
  - 최대한 빨리 취약점에 영향을 받는 **모든 시스템을 업데이트**
  - 복원 계획을 포함한 우리의 **대응 과정을** 파트너/고객 등 **외부에 전달** 
  
#### 5. 서킷 브레이커

- 1) 개념
  - 서비스 장애를 감지하고 연쇄적으로 생기는 오류 전파를 방지하는 기법
  - 연쇄적 장애 전파 막기 위해 자동으로 외부 서비스와 연결을 차단/복구
  - 서비스-서비스간 서킷브레이커 계층을 둠
  - 연속적인 에러를 막아 일부 서비스 종료되더라도 다른 서비스 동작 가능
  
- 2) 서킷 브레이커 동작과정
![](https://velog.velcdn.com/images/24tngus/post/072e2f6b-ab36-45e1-aafe-7a9761287be7/image.png)
- 서킷 브레이커를 서비스간 사이에 넣고 관련 함수들 래핑
- 네트워크 장애를 모니터링하여 특정 서비스가 timeou으로 설정된 시간 초과할 경우
  - 몇번의 요청을 한 이후에도 계속 timeout 시간을 초과하면 장애로 인식 (에러 반환)
- 서킷 브레이커가 trip 되며 그 이후 추가적인 호출은 발생X (fail fast)
  - trip : 서킷 브레이커 open 된 상태
  - closed 상태라면 기본적인 요청 수행하고, open된 상태라면 요청 수행하지 않고 빠르게 오류 반환

- 3) 서킷 브레이커 상태
  - closed[정상] : 네트워크 요청의 실패율이 임계치보다 낮음
  - open[오류] : 임계치 이상의 상태, 요청을 서비스로 전송하지 않고 바로 오류 반환 (fail fast)
  - half_open[확인중] : 장애가 해결되었는 지 확인을 위해 요청을 전송하여 응답 확인 (장애 풀리는지 확인 후 성공시 closed, 실패시 open)
  ![](https://velog.velcdn.com/images/24tngus/post/c1b7b279-dfe8-4844-a769-d58538edc0a7/image.png)

- 4) 구현
  - 넷플릭스의 [Hystrix](https://github.com/Netflix/Hystrix)와 [Resilience4j](https://github.com/resilience4j/resilience4j)

#### 6. 컨텐츠 관리

- 1) 불필요한 컨텐츠 제거
  - 불필요한 쿼리 등 제거
    - 인덱스를 추가하거나 쿼리를 변경해서 인덱스 사용하도록 개선
    - 개선이 안되는 쿼리라면 차라리 기능 OFF
    - `select *`로 조회하던 쿼리에서 실제 기능이 사용되지 않는 칼럼 모두 제거
  - 🗒️ 예시 : 인프런의 장애 복구 사례
    - 고용량의 컬럼을 강의 관련 쿼리에서 조회 항목에 포함시켜 가져옴
  ![](https://velog.velcdn.com/images/24tngus/post/18fe1e3b-7f98-4254-8d3e-e0f35c9cf4da/image.png)

- 2) CDN을 통한 컨텐츠 제공
  - 분산된 대규모 서버 네트워크를 기반으로 컨텐츠를 제공해서 서버 부하 줄임
  - CDN (Content Delivery Network) : 분산된 서버를 연결한 네트워크 
  
- 3) 컨텐츠 캐싱
  - 브라우저 캐시(쿠키, 로컬저장소, 세션저장소)를 통해 해당 요청에 관한 항목을 캐시에서 응답을 읽어 네트워크 요청에 관한 비용을 모두 제거
  
- 4) 컨텐츠 압축
  - 텍스트 기반 리소스는 gzip 또는 Brotli 통해 압축함 (70% 까지 압축)
  - 압축을 풀기 위해 서버에서 자원(CPU)를 사용하는 양 고려 필요
  
- 5) 컨텐츠 미리 준비된 응답
  - 시스템의 과도한 부하를 줄이기 위해 제공하는 컨텐츠 및 기능일 일시적으로 줄임
  - 방식 
    - 정적 테스트 페이지 제공 
    - 검색 비활성화
    - 더 적은 수의 검색 결과 반환
    - 필수적인지 않은 기능 비활성화