# 인덱스란? 효율적인 이유?

1. `인덱스란?`
    
    → 데이터베이스에서 테이블의 검색 속도 향상을 위한 `자료구조`로서 , 책에서 봤을 때는 목차와 같은 역할. 
    
    → 검색 속도 향상이지만, 어디있는지 알아야(SELECT) 작업이 가능한 UPDATE, DELETE도 함께 성능이 향상된다. 
    
2. `효율적인 이유`
    
    index를 사용한다면 DB를 Full Scan 하는것이 아니기 때문에, 속도가 빨라지는것 !
    

# 인덱스에 사용되는 자료구조(해시 테이블, B+Tree)

## 해시 테이블

![Untitled](https://github.com/24tngus/CS_STUDY/assets/101094583/f74d6664-bcc4-4c4f-8ac3-723d0aad66d5)

- Key, Value로 데이터를 저장하는 자료구조
    - 조회를 할 때에는 시간 복잡도가 O(1)로서 빠른 데이터 검색에 유용
    - 해시 테이블 기반의 DB 인덱스 (key = 데이터 | value = 데이터 위치) 를 통해 구현
    - 해시 테이블은 = 연산에만 특화, 하지만 DB특성상 > < 연산이 많기때문에 적합하지 않다 ⇒ 따라서 B+Tree라는 자료구조를 이

## B+Tree

![2](https://github.com/24tngus/CS_STUDY/assets/101094583/5d2aee4b-9ee4-4a1e-ab89-6bd31c272a61)

- 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조 ⇒ B+Tree
    - 루트 노드, 브랜치 노드, 리프 노드등 각각의 노드들은 LinkedList 로 연결되어 > < 연산을 통해 리프노드의 데이터를 찾으므로, 해시 테이블 보다 인덱싱에 더욱 적합한 자료구조 이다.
    - 시간 복잡도는 O(log2N)이다.

# 인덱스의 장, 단점

## 장점

1. 테이블을 조회하는 속도, 그에 따른 성능 향상 가능
2. 전반적인 시스템 부화 감소 가능
3. 대수확장성 : 트리 깊이가 리프 노드의 수에 비해 매우 느리게 성장한다, 트리의 depth가 1씩 증가하면 최대 인덱스 항목의 수는 2*2배 씩증가한다

## 단점

1. 인덱스 관리를 위해 데이터베이스의 10%해당하는 저장공간이 필요하다.
2. 인덱스 관리를 위한 추가작업이 필요하다.
3. 적절하지 못한 인덱스는 오히려 성능이 저하될 수 있다.

## 효율적인 관리 방법

1. PK → 중복이 없으므로 해당 컬럼을 인덱스로 사용한다.
2. WHERE 절에서 자주사용되는 컬럼을 인덱스로 사용한다. ⇒ Table 을 FullScan 할 필요가 사라지므로
3. Insert, Delete, Update가 자주 발생하지 않는 컬럼을 인덱스로 사용한다.
4. Join, Where, Order By가 자주 일어나는 컬럼을 인덱스로 사용한다.

## Clustered(정렬된) vs NonClustered(정렬되지 않은)

 

- Clustered Index → 검색 속도 향상 But 데이터 삽입시 많은 비용이 소모된다는 단점

![3](https://github.com/24tngus/CS_STUDY/assets/101094583/31015ffd-e5fa-4ada-b28a-313ecb43b5b2)

- NonClustered →  테이블 데이터와 함께 저장되는 것이 아니라, 별도의 장소에 처리되므로, 인덱스 키값에 해당  행을 가리키는 포인터가 존재

![4](https://github.com/24tngus/CS_STUDY/assets/101094583/3b84f5ab-41df-4887-b23a-695baab13c50)

![5](https://github.com/24tngus/CS_STUDY/assets/101094583/ccdf1550-4ec1-40e2-afd5-fd7b0b0f547d)

- 사용할때
    - Clustered  인덱스의 경우 Select 의 작업이 많을 경우 사용해야하고 Non Clustered 인덱스의 경우 CUD의 작업이 많을 경우 사용해야 한다.

![6](https://github.com/24tngus/CS_STUDY/assets/101094583/99712511-b9bc-42f5-9344-49e5018a7cfc)

## 인덱스 최적화 기법

1. 인덱스는 비용이다.
    1. 인덱스는 두 번 탐색되게 되어있는데 → 이때 읽기 비용이 들어간다.
    2. 균형잡힌 트리의 높이를 사용해라
2. 항상 테스팅 하라
3. 복합 인덱스
    1. 어떠한 값을 비교하는 == equal 쿼리를 설정, 자주사용하는 쿼리
    2. 정렬 
    3. 다중 값 
    4. age, name이 있을때 더 유니크한 name을 사용해라
