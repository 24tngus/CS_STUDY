1.데드락 (Deadlock)의 정의

![image](https://github.com/24tngus/CS_STUDY/assets/122462263/59767e58-31e9-49d2-a6d7-e5ea6669cd7e)


 트랜잭션이 다른 트랜잭션이 점유하고 있는 자원을 서로 기다릴 때 무한 대기 상태가 된다. 이 상황을 Deadlock(교착상태)라고 한다.데이터베이스는 데이터의 일관성과 무결성을 유지해야 할 필요가 있기 때문에 lock이 되어 있다. locking이 되지 않은 상태에서 트랜잭션들이 동시성 제어가 되지 않기 때문에 여러 문제점들이 일어난다. 때문에 locking 기법은 필요하지만 잘못 사용하면 데드락이 발생하게 되는 것이다.



2. 데드락의 발생 조건
1) 상호 배제
 한번에 하나의 프로세스만 사용할 수 있다.

2) 점유와 대기
하나의 프로세스가 점유하고 있을 떄, 다른 프로세스는 다른 프로세스의 자원을 점유하기 위해선 대기해야 한다.

3) 비선점
점유된 자원은 강제로 해제될 수 없고, 프로세스가 자원의 사용을 자발적을 해제하기 전까지 그 자원은 얻을 수 없다.

4) 순환 대기
자원과 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 한다.

데드락 발생조건 4가지 중 하나를 부정하면서  데드락을 예방할 수 있다. 하지만 발생조건을 피하면서 설계하는 것은 효율성이 떨어지기 때문에 다른 방법들을 사용한다. 

3. 데드락 해결방법
1) 교착상태 감지
교착상태를 감지 및 timeout : 일정시간 이후 트랜직션이 실행되지 않을경우 롤백하게 한다.
그래프 기반으로 사이클을 탐색 : 그래프 내의 사이클이 형성되었다는 것을 기반으로 교착상태를 감지한다.

![image](https://github.com/24tngus/CS_STUDY/assets/122462263/ca047669-caab-4f54-bf40-1cc8fe95c002)

그래프 기반으로 사이클을 탐색한다는 말은 트랜잭선 2가 트랜잭션 1를 요청했을 때 트랜잭션1이 대기상태에 놓여있기에 자원 요청에 대해 사이클이 발생한다는 의미이다. 

*대규모 데이터베이스의 경우에는 일일이 감지해 내기에는 코스트가 너무 크기 때문에 교착상태 방지를 더 많이 쓴다.



2) 교착상태 방지
격리 수준 변경 : 교착 상태를 방지하기 위해 격리 수준을 행수준 잠금 또는 격치 수준을 조정한다.
서비스 로직을 교차되지 않게 수정 : 서비스 논리 구조를 교차되지 않고 일관성 있게 바꾼다.
wait-die 또는 wond wait방법 : 타임스탬프를 기반으로 트랜잭션을 대기, 선점, 종료하는 방식


wait-die : 기다리거나 죽이거나
- 트랜잭션 a가 b에 의해 로킹된 데이터를 요청할 때 b가 먼저 들어온 트랜잭션이면 wait하고 b가 늦게 들어온 트랜잭션이면 die하는 방법이다.

wond wait : 빼앗거나 기다리거나
- 트랜잭션 a가 b에의해 로킹된 데이터를 요청할 때 a가 먼저 들어온 트랜잭션이면 먼저 선점(wond)한다. 하지만 a가 늦게들어온 트랜잭션이면 기다린다(wait).

